## 类加载器的介绍

之前也提到了它是负责加载.class文件的，它们在文件开头会有特定的文件标示，将class文件字节码内容加载到内存中，并将这些内容转换成方法区中的运行时数据结构，并且ClassLoader只负责class文件的加载，而是否能够运行则由Execution Engine决定。

### 类加载器的流程

从类被加载到虚拟机内存中开始，到释放内存总共有7个步骤：加载，验证，准备，解析，初始化，使用，卸载。

其中 **验证，准备，解析三个部分统称为连接**

#### 加载

1. 将class文件加载到内存
2. 将静态数据结构转化成方法区中运行时的数据结构
3. 在堆中生成一个代表这个类的 java.lang.Class 对象作为数据访问的入口

#### 连接

1. 验证：确保加载的类符合JVM规范和安全，保证被校验类的方法在运行时不会做出危害虚拟机的事情，其实就是一个安全检查

2. 准备：为static变量在方法区中分配内存空间，设置变量的初始值，例如static int a = 3 

   > 注意：准备阶段只设置类中的静态变量（方法区中），不包括实例变量（堆内存中），实例变量是对象初始化时赋值的

3. 解析：虚拟机将常量池内的符号引用替换为直接引用的过程

#### 初始化

初始化其实就是一个赋值的操作，它会执行一个类构造器的 `clinit` 方法。由编译器自动收集类中所有变量的赋值操作，此时准备阶段时的那个 static int a = 3 的例子在这个时候就正式赋值为3

#### 卸载

GC将无用对象从内存中卸载

### 类加载器的加载顺序

加载一个Class类的顺序也是有优先级的，类加载器从最底层开始往上的顺序是这样的

1. BootStrap ClassLoader: rt.jar
2. Extention ClassLoader: 加载扩展的jar包
3. App ClassLoader：指定的classpath下面的jar包
4. Custom ClassLoader：自定义的类加载器

### 双亲委派机制

当一个类收到了加载请求时，它是不会先自己去尝试加载的，而是委派给父类去完成，比如我现在要new一个Person，这个Person是我们自定义的类，如果我们要加载它，就会先委派App ClassLoader，只有当父类加载器都反馈自己无法完成这个请求（也就是父类加载器都没有找到加载所需的Class）时，子类加载器才会自行尝试加载。

这样做的好处是，加载位于rt.jar包中的类时不管是哪个加载器加载，最终都会委托到BootStrap ClassLoader进行加载，这样保证了使用不同的类加载器得到的都是同一个结果。

主要起到一个 **隔离** 的作用，避免我们的代码影响了JDK的代码。

## 运行时数据区

### 本地方法栈和程序计数器

用 `native` 关键字修饰的，不存在方法体，这种就是本地方法，用C实现的，一般这些方法都会放到一个叫做本地方法栈的区域。

程序计数器其实就是一个指针，它指向了我们程序中下一句需要执行的指令，它也是内存区域中唯一一个不会出现OutOfMemoryError的区域，而且占用内存空间小到基本可以忽略不计。这个内存仅代表当前线程所执行的字节码的行号指示器，字节码解析器通过改变这个计数器的值选取下一条需要执行的字节码指令。

如果执行的是native方法，那这个指针就不工作了。

### 方法区

方法区主要的作用技术存放类的元数据信息，常量和静态变量...等。当它存储的信息过大时，会在无法满足内存分配时报错。

### 虚拟机栈和虚拟机堆

栈管运行，堆管存储。虚拟机栈负责运行代码，而虚拟机堆负责存储数据。

**虚拟机栈的概念**

它是java方法执行的内存模型。里面会对局部变量，动态链表，方法出口，栈的操作进行存储，且线程独享。**局部变量表，**也是指虚拟机栈。

```java
public class Person {
    int a = 1;
    public void doSometing() {
        int b = 2;
    }
}
```

**虚拟机栈存在的异常**

如果线程请求的栈的深度大于虚拟机栈的最大深度，就会报 **StackOverflowError**.

Java虚拟机也可以动态扩展，但随着扩展会不断地申请内存，当无法申请足够内存时就会报错 **OutOfMemoryError**

**虚拟机栈的生命周期**

对于栈来说，不存在垃圾回收。只要程序运行结束，栈的空间自然就会释放了。栈的生命周期和所处的线程是一致的。

> 8种基本类型的变量+对象的引用变量+实例方法都是在栈里面分配内存

**虚拟机栈的执行**

我们经常说的栈帧数据，在JVM中叫做栈帧，放到Java中其实就是方法，它也是存放在栈中的。

栈中的数据都是以栈帧的格式存在，它是一个关于方法和运行期数据的数据集。比如我们执行一个方法a，就会对应产生一个栈帧A1, 然后A1会被压入栈中。同理方法b会有一个B1, 方法c会有一个C1，等到这个线程执行完毕后，栈会先弹出C1，后B1，A1。它是一个先进后出，后进先出原则。

**局部变量的复用**

局部变量表用于存放方法参数和方法内部所定义的局部变量。它的容量是以Slot为最小单位，一个slot可以存放32位以内的数据类型。

虚拟机通过索引定位的方式使用局部变量表，范围为 `[0, 局部变量表的slot的数量]` 。方法中的参数就会按一定顺序排列在这个局部变量表中。为了节省栈帧空间，这些slot是可以复用的，当方法执行位置超过了某个变量，那么这个变量的slot可以被其它变量复用。当然如果需要复用，那我们的垃圾回收自然不会去动这些内存。

**虚拟机堆的概念**

JVM内存会划分为堆内存和非堆内存，堆内存中也会划分会 **年轻代** 和 **老年代**，而非堆内存则为 **永久代**。 年轻代又会分为 **Eden** 和 **Survivor** 区。Survivor也会分为 **FromPlace** 和 **ToPlace**，toPlace的Survivor区域是空的。Eden，FromPlace和ToPlace的默认占比是 **8:1:1** 。这个东西可以通过一个 `XX: +UsePSAdaptiveSurvivorSizePolicy` 参数来根据生成对象的速率动态调整。

堆内存中存放的是对象，垃圾收集就是收集这些对象然后交给GC算法进行回收。非堆内存，其实就是 **方法区**。 在1.8中已经移除永久代，替代品是一个元空间（MetaSpace），最大区别是metaSpace是不存在于JVM中的，它使用的是本地内存。并有两个参数：

```java
MetaspaceSize: 初始化元空间大小，控制发生GC
MaxMetaspaceSize: 限制元空间大小上限，防止占用过多物理内存
```

移除的原因：融合HotSpot JVM 和JRokit VM而做出的改变，因为JRockit是没有永久代的，不过这也间接性地解决了永久代的OOM问题。

**Eden年轻代的介绍**

当我们new一个对象后，会先放到Eden划分出来的一块作为存储空间的内存，但是我们知道堆内存是线程共享的，所以有可能会出现两个对象共用一个内存的情况，这里JVM的处理是每个线程都会预先申请好一块连续的内存空间并规定了对象存放的位置，而如果空间不足会再申请多块内存空间。这个操作被称为TLAB。

当Eden空间满了之后，会触发一个叫做Minor GC 的操作，存活下来的对象移动到Survivor0 区

**如何判断一个对象需要被干掉**

程序计数器、虚拟机栈、本地方法栈。三个区域随着线程的生存而生存的。内存分配和回收都是确定的。随着线程的结束内存自然就被回收了，因此不需要考虑垃圾回收的问题。而Java堆和方法区则不一样，各线程共享，内存的分配和回收都是动态的。因此垃圾收集器所关注的都是堆和方法这部分内存。

在进行回收前就要判断哪些对象还存活，哪些已经死去。下面是两个基础的计算方法：

1. 引用计数器计算：给对象添加一个引用计数器，每次引用这个对象时计数器加一，引用失效时减一，计数器等于0时就是不会再次使用的。不过有一种情况就是出现对象的循环引用时GC没法回收。

2. 可达性分析计算：这是一种类似于二叉树的实现，将一系列的GC ROOTS作为起始的存活对象集，从这个节点往下搜索，搜索所走过的路径成为引用链，把能被该集合引用到的对象加入到集合中。搜索当一个对象到GC Roots没有使用任何引用链时，则说明该对象是不可用的。

   在Java中能作为GC Roots的对象有以下几种：

   1. 虚拟机栈中引用的对象
   
   2. 方法区中静态变量所引用的对象
   
   3. 方法区中常量引用的对象
   
   4. 本地方法栈中JNI引用的对象
   
      > JNI是Java虚拟机调用对应的C函数的方式，通过JNI函数也可以创建新的Java对象。且JNI对于对象的局部引用或者全局引用都会把它们指向的对象都标记为不可回收
   
   5. 已启动的且未终止的Java线程
   
   这种方法的优点是能够解决循环引用的问题，可它的实现需要耗费大量资源和时间，也需要GC

**如何宣告一个对象的真正死亡**

首先必须要提到的是一个名叫 **finalize()** 的方法

finalize() 是 Object类的一个方法、一个对象的finalize()方法只会被系统自动调用一次，经过finalize()方法逃脱死亡的对象，第二次不会再调用。

不提倡使用该方法，在Java9中已经被标记为 **deprecated** 

判断一个对象的死亡至少需要两次标记

1. 如果对象进行可达性分析之后没有发现与GC Roots相连的引用链，那它将会第一次标记并且进行一次筛选。判断的条件是决定这个对象是否有必要执行finalize()方法。如果对象有必要执行finalize() 方法，则被放入F-Queue 中
2. 

### 垃圾回收算法

#### 标记清除算法

标记清除算法就是分为“标记”和“清除”两个阶段。标记出所有需要回收的对象，标记结束后统一回收。这个套路很简单，也存在不足，后续的算法都是根据这个基础加以改进的。

其实它就是把已死亡的对象标记为空闲内存，然后记录在一个空闲列表中，当我们需要new一个对象时，内存管理模块会从空闲列表中寻找空闲的内存来分给新的对象。

不足的方面就是标记和清除的效率比较地下。且这种做法会让内存中的碎片非常多。这个导致了如果我们需要用到较大的内存时，无法分配到足够的连续内存。

#### 复制算法

为了解决效率问题，复制算法就出现了。它可用内存按容量划分为两等分，每次只使用其中的一块。和Survivor一样也是用from 和 to 两个指针。fromPlace存满了，就把存活的对象copy到另一块toPlace上，然后交换指针的内容。这样就解决了碎片的问题。

这个算法的代价就是把内存缩水了，这样堆内存的使用效率就会变得十分地下。

> 它们分配的时候也不是按照1:1这样分配的，类似于Eden和Survivor也不是等价分配

#### 标记整理算法

复制算法在对象存活率高的时候会有一定的效率问题，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存

#### 分代收集算法

根据对象存活周期的不同将内存划分为几块。一般是Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率搞、没有额外空间对它进行分配担保，就必须使用“标记-清除”或者“标记-整理”算法来进行回收。

### 各种垃圾回收器

HotSpotVM 中的垃圾回收器，以及适用场景

| 收集器            | 串行、并行、并发 | 新生代/老年代 | 算法 | 目标 | 适用场景 |
| ----------------- | ---------------- | ------------- | ---- | ---- | -------- |
| Serial            |                  |               |      |      |          |
| Serial Old        |                  |               |      |      |          |
| ParNew            |                  |               |      |      |          |
| Parallel Scavenge |                  |               |      |      |          |
| Parallel Old      |                  |               |      |      |          |
| CMS               |                  |               |      |      |          |
| G1                |                  |               |      |      |          |

到jdk8为止，默认的垃圾回收器是 `Parallel Scavenge` 和 `Parallel Old`

从jdk9起，G1收集器成为默认的垃圾收集器





























































