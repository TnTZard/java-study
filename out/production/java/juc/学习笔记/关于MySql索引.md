## 事务

### 事务的四大特性（ACID）

1. **原子性（Atomicity）**：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
2. **一致性（Consistency）**：执行事务后，数据库从一个正确的状态变化到另一个正确的状态。
3. **隔离性（isolation）**：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的。
4. **持久性（Durability）**：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

**SQL标准定义了四个隔离级别**

```mysql
mysql> select @@tx_isolation;
+-----------------+
| @@tx_isolation  |
+-----------------+
| REPEATABLE-READ |
+-----------------+
1 row in set (0.02 sec)
```

默认的隔离级别是 **REPEATABLE-READ** **(可重复读)**。

### 并发事务带来的问题

- **脏读（Dirty read）：** 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。那么这个数据也就成了**脏数据**。
- **丢失修改（Lost to modify）:** 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。**（我的理解就是两个事务执行的先后顺序导致第一个事务修改的结果无效或者说被掩盖）**
- **不可重复读（Unrepeatableread）:** 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务内的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。
- **幻读 （Phantom read）：** 幻读与不可重复读类似。它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以被称为幻读。

**不可重复读和幻读区别：**不可重复读的重点是**修改**，比如多次读取一条记录发现其中某些列的值被修改；幻读的重点在于**新增或者删除**，比如多次读取一条记录发现记录增多或减少了。

### 事务隔离级别

**SQL标准定义了四个隔离级别：**

- **读取未提交：** 最低的隔离级别，允许读取尚未提交的数据变更，**可能会导致脏读、幻读或不可重复读。**
- **读取已提交：** 允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻读或不可重复读仍有可能发生**
- **可重复读：** 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生**
- **可串行化：**最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读

**回到最开始那句话**，MySql InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ（可重读）。**

> 注意：与SQL标准不同的地方在于InnoDB存储引擎在 **REPEATABLE-READ（可重读）**事务隔离级别下使用的是 Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统（如SQL Server）是不同的。所以说InnoDB存储引擎的默认支持的隔离级别是 **可重读**，已经可以完全保证事务的隔离性要求，即达到了SQL标准的 **可串行化** 隔离级别。因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 **读取提交内容**，但是InnoDB存储引擎默认使用 **可重读**并不会有任何性能损失。

InnoDB存储引擎在 **分布式事务** 的情况下一般会用到 **SERIALIZABLE(可串行化)**隔离级别。

### 锁机制与InnoDB锁算法

- MyISAM采用表级锁（table-level locking）
- InnoDB支持行级锁（row-level locking）和表级锁，默认为行级锁

表级锁和行级锁对比：

- **表级锁：**MySQL中锁定 **粒度最大** 的一种锁，对当前操作的
- **行级锁：**MySQL中锁定 **粒度最小** 的一种锁，只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。

**InnoDB存储引擎的锁的算法有三种：**

- Record lock：单个行记录上的锁
- Gap lock：间隙锁，锁定一个范围，不包括记录本身
- Next-key lock：record + gap 锁定一个范围，包含记录本身

相关知识点：

1. InnoDB对于行的查询使用next-key lock
2. Next-key lock为了解决Phantom Problem幻读问题
3. 当查询的索引含有唯一属性时，将next-key lock降级为record key
4. Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生
5. 有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock）
   - 将事务隔离级别设置为RC
   - 将参数`innodb_locks_unsafe_for_binlog`设置为1





## 索引

**优点：**大大加快数据的检索速度（大大减少检索的数据量)，这也是创建索引的最主要原因。毕竟大部分系统的读请求总是大于写请求的。另外，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。

**缺点：** 1.**创建索引和维护索引需要耗费许多时间**

​			2.**占用物理存储空间**

### B树和B+树的区别

- B树的所有节点既存放key也存放data；而B+树只有叶子节点存放key和data，其他内节点只存放key。

- B树的叶子节点都是独立的；B+树的叶子节点有一条引用链指向与它相邻的叶子节点

- B树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到叶子节点，检索就结束了；

  B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索就很明显。





### 索引类型

#### 主键索引（Primary Key）

数据表的主键列使用的就是主键索引

一张表有且只能有一个主键，并且主键不能null，不能重复。

在mysql的InnoDB的表中，当没有显示的指定表的主键时，InnoDB会自动先检查表中是否有唯一索引的字段，如果有，则选择该字段为默认的主键，否则InnoDB将会自动创建一个6byte的自增主键。

#### 二级索引（辅助索引）

二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。

唯一索引，普通索引，前缀索引等索引属于二级索引。

1. **唯一索引（Unique Key）：** 唯一索引也是一种约束、唯一索引的属性列不能出现重复的数据，但是允许数据为NULL，一张表允许创建多个唯一索引。建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。
2. **普通索引（Index）：**普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和NULL。
3. **前缀索引（Prefix）：**前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小，因为只取前几个字符。
4. **全文索引（Full Text）：**全文索引主要是为了检索大文本数据中心的关键字信息。

## 聚集索引和非聚集索引--从物理存储角度

### 聚集索引

**聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。一个表只能有一个聚集索引。**

在Mysql中，InnoDB引擎的表的 `.idb` 文件就包含了该表的索引和数据，对于InnoDB引擎表来说，该表的索引（B+树）的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。

**聚集索引的优点**

聚集索引的查询速度非常快，因为整个B+树本身就是一棵多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据

**聚集索引的缺点**

1. **依赖于有序的数据：**因为B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或UUID这种又长又男比较的数据，插入或查找的速度肯定比较慢。
2. **更新代价大：**如果对索引列的数据被修改时，那么对应的索引也将会被修改。而且聚集索引的叶子节点还存放着数据，修改代价肯定较大，所以对于主键索引来说，主键一般都是不可被修改的。

### 非聚集索引

**非聚集索引即索引结构和数据分开存放的索引。**

**二级索引属于非聚集索引。**

> MYISAM引擎的表的.MYI文件包含了表的索引

**非聚集索引的优点**

**更新代价比聚集索引小。**非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的。

**非聚集索引的缺点**

1. 和聚集索引一样，非聚集索引也依赖于有序的数据
2. **可能会二次查询（回表）：** 非聚集索引最大的缺点。当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。

#### 非聚集索引一定回表查询吗（覆盖索引）？

非聚集索引不一定回表查询

1. 当用户准备使用SQL查询用户名，而用户名字段正好建立了索引

   > SELECT name FROM table WHERE username='xxx';

   这个索引的key本身就是name，查到对应的name直接返回就行了，无需回表查询。

**即使是MYISAM也是这样，虽然MYISAM的主键索引确实需要回表，因为它的主键索引的叶子节点存放的是指针。但是如果SQL查的就是主键呢？**

> SELECT id FROM table WHERE id = 1;

主键索引本身的key就是主键，查到返回就行，这种情况就称为覆盖索引。

### 覆盖索引

如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。我们知道在InnoDB存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢，覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！

**覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询。**

> 比如主键索引，如果一条SQL需要查询主键，那么正好根据主键索引就可以查到主键
>
> 比如普通索引，如果一条SQL需要查询name，name字段正好有索引，那么直接根据这个索引就可以查到数据，也无需回表。



## 索引创建原则

### 单列索引

单列索引即由一列属性组成的索引。

### 联合索引（多列索引）

联合索引即由多列属性组成索引。

### 最左前缀原则

假设创建的联合索引由三个字段组成：

> ALTER TABLE table ADD INDEX index_name (num, name, age)

那么当查询的条件有为：num 或 num AND name 或 num AND name AND age 时，索引才生效。所以在创建联合索引的时候，尽量把查询最频繁的那个字段作为最左（第一个）字段。查询的时候也尽量以这个字段为第一条件。

### 索引创建注意点

1. 最左匹配原则
2. 选择合适的字段：
   - 不为NULL的字段
   - 被频繁查询的字段
   - 被作为条件查询的字段
   - 被频繁用于连接的字段
3. 不合适创建索引的字段：
   - **被频繁更新的字段应该慎重建立索引**，维护索引的成本不小，如果一个字段不被经常查询，反而被经常修改，那么不应该在这种字段上建立索引。
   - **不被经常查询的字段没有必要建立索引**
   - **尽可能的考虑建立联合索引而不是单列索引**
   - **注意避免冗余索引**
   - **考虑在字符串类型的字段上使用前缀索引代替普通索引**

> 大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引的效果也不会很明显







































































## MVCC

全称Multi-Version Concurrency Control, 即 `多版本并发控制`，主要是为了提高数据库的 `并发性能`。

