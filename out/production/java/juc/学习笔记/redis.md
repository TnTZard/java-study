## Redis单线程模型详解

**Redis基于Reactor模式来设计开发了自己的一套高效的时间处理模型**（Netty的线程模型也基于Reactor模式，Reactor模式是高性能IO的基石），这套事件处理模型对应的是Redis中的文件事件处理器（file event handler）。由于文件事件处理器（file event handler）是单线程方式运行的，所以我们一般都说Redis是单线程模型。

**既然是单线程，那怎么监听大量的客户端连接？**

Redis通过 **IO多路复用程序** 来监听来自客户端的大量连接（或者说是监听多个socket），它会将感兴趣的事件及类型（读、写）注册到内核中并监听每个事件是否发生。

这样的好处非常明显：**I/O多路复用技术的使用让Redis不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗**（和NIO中的 `Selector` 组件很像）

Redis服务器是一个事件驱动程序，服务器需要处理两类事件：1.文件事件；2.时间事件

**文件事件**（客户端进行读取写入等操作，涉及一系列网络通信）。

> Redis基于Reactor模式开发了自己的网络事件处理器；这个处理器被称为文件事件处理器（file event handler）。文件事件处理器使用I/O多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。
>
> 当被监听的套接字准备好执行应答（accept）、读取（read）、写入（write）、关闭（close）等操作时，与操作相对应的文件事件就会产生，这时，文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。
>
> **虽然文件事件处理器以单线程方式运行，但通过使用I/O多路复用程序来监听多个套接字，**文件事件处理器既实现了高性能的网络通信模型，又可以很好地与Redis服务器中其他同样以单线程方式运行的模块进行对接，这保持了Redis内部单线程设计的简单性。

可以看出，文件事件处理器（file event handler）主要包含4部分：

- 多个socket（客户端连接）
- IO多路复用程序（支持多个客户端连接的关键）
- 文件事件分派器（将socket关联到相应的事件处理器）
- 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）

## IO多路复用（时间响应模型）

多路 指 **多个网络连接**

复用 指 **复用同一个线程**

采用多路I/O复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗）



## 过期数据的删除策略

常用的过期数据的删除策略：

1. **惰性删除：** 只会在取出key的时候才对数据进行过期检查。这样对CPU最友好，但是可能会在造成太多过期key没有被删除 。
2. **定期删除：**每隔一段时间抽取一批key执行删除过期key操作。并且，Redis底层会通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。

定期删除对内存更加友好，惰性删除对CPU更加友好，两者各有千秋，所以Redis采用的是 **定期删除 + 惰性/懒汉式删除**。

但是，仅仅通过给key设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期key的情况，这就导致大量过期的key堆积在内存里，然后就Out of memory。

## 内存淘汰机制

Redis提供6种数据淘汰策略：

1. **volatile-lru （least recently used）：** 从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰。
2. **volatile-ttl：** 将要过期的数据淘汰
3. **volatile-random：** 任意选择数据淘汰
4. **allkeys-lru（least recently used）：** 当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）
5. **allkeys-random：** 从数据集中任意选择数据淘汰
6. **no-eviction：** 禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。（基本不使用）

4.0版本后增加以下两种：

7. **volatile-lfu（least frequently used）：** 从已设置过期时间的数据集中挑选最不经常使用的数据淘汰
8. **allkeys-lfu（least frequently used）：** 当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的key

## Redis集群以及应用

**主从复制，主从链**

**复制模式：**

- 全量复制：Master全部同步到Slave
- 部分复制：Slave数据丢失进行备份

**问题点：**

- 同步故障：
  1. 复制数据延迟（不一致）
  2. 读取过期数据（Slave不能删除数据）
  3. 从节点故障
  4. 主节点故障
- 配置不一致：
  1. maxmemory不一致：丢失数据
  2. 优化参数不一致；内存不一致
- 避免全量复制：
  1. 选择小主节点（分片）、低峰期间操作，
  2. 如果节点运行id不匹配



### 使用场景

**热点数据**

存取数据优先从Redis操作，如果不存在再从文件（例如MySQL）中操作，从文件操作完后将数据存储到Redis中并返回，。同时有个定时任务后台定时扫描Redis的key，根据业务规则进行淘汰，防止某些只访问一两次的数据一直存在Redis中。

> 例如使用Zset数据结构，存储Key的访问次数、最后访问时间作为Score，最后做排序，来淘汰那些最少访问的key。

**会话维持Session**

使用Redis作为分布式场景下的登录中心存储应用

**分布式锁SETNX**

`SETNX key value` 只有当key不存在，将key的值设为value。如果给定的key已经存在，则SETNX不做任何动作。

**表缓存**

Redis缓存表的场景有黑名单、禁言表等。访问频率较高，即读高。根据业务需求，可以使用后台定时任务定时刷新Redis的缓存表数据。

**消息队列list**

主要使用List数据结构。List支持在头部和尾部操作，因此可以实现简单的消息队列。





### 什么是RedLock

它可以保证以下特性：

1. 安全特性：互斥访问，即永远只有一个client能拿到锁。
2. 避免死锁：最终client都可能拿到锁，不会出现死锁的情况，即使原本锁住某资源的client crash 了或者出现了网络分区
3. 容错性：只要大部分Redis节点存活就可以正常提供服务

### 怎么在单节点上实现分布式锁

















































#### activerehashing yes

是否开启顶层数据结构的rehash功能,如果内存允许,请开启。rehash能够很大程度上提高K-V存取的效率

#### hz 10

Redis Server执行后台任务的频率，默认为10，此值越大表示redis对“间歇性task”的执行次数越频繁。"间歇性task"包括"过期集合"检测、关闭"空闲超时"的连接等,此值必须大于0且小于500。此值过小就意味着更多的cpu周期消耗,后台task被轮询的次数更频繁。此值过大意味着"内存敏感"性较差

